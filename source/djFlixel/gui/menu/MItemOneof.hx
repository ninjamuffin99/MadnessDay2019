package djFlixel.gui.menu;

import djFlixel.gui.Styles;
import djFlixel.tool.DEST;
import djFlixel.tool.DataTool;
import flixel.FlxG;
import flixel.FlxSprite;
import flixel.text.FlxText;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.tweens.misc.NumTween;


class MItemOneof extends MItemBase
{
	// How far out the arrows will move
	// Multiplier on the font_size, seems ok - ARBITRARY but looks ok -
	inline static var NUDGE_RATIO:Float = 0.4;
	// Default arrow loop time
	inline static var DEF_NUDGE_TIME:Float = 0.4;
	
	// Displayed text
	var label2:FlxText;

	// Hold 2 arrows and their status
	var arrows:Array<FlxSprite>;
	var arrowStat:Array<Bool>;
	
	// Animate the cursors with a tween
	var arrow_tween:NumTween;	
	
	//---------------------------------------------------;
	public function new(_s:StyleVLMenu,_w:Int)
	{
		super(_s, _w);
		
		// The variable selection
		label2 = new FlxText();
		Styles.applyTextStyle(label2, style);
		add(label2);
		
		// --
		arrows = [];
		arrowStat = [];
		
		// -- Setup the graphics ::
		
		var c = DataTool.copyFields(style.icons, {
			image:null,
			size:Gui.getApproxIconSize(style.fontSize),
			sliderText:null,
			sliderTime:DEF_NUDGE_TIME
		});
		
		if (c.sliderText != null) // Use text for the arrows
		{
			for (a in 0...2) {
				var t = new FlxText(0, 0, 0, c.sliderText[a]);
				Styles.applyTextStyle(t, style);
				t.color = style.color;
				arrows[a] = cast t;
				arrows[a].visible = false;
				add(arrows[a]);
			}
		}
		else	// Use icons
		{
			for (a in 0...2) {
				var bm = Gui.getIcon(["ar_left", "ar_right"][a],
								c.size,
								c.image,
								style.color_icon_shadow,
								cast label.borderSize,	// Get thelabel size because it could be autogenerated
								cast label.borderSize);
				arrows[a] = new FlxSprite(0, 0, bm);
				arrows[a].visible = false;
				arrows[a].y = (height / 2) - (c.size / 2) + 3; // Verical Align, +3 works a bit better
				arrows[a].replaceColor(0xFFFFFFFF, style.color_focused); // #COLOR
				add(arrows[a]);
			}
		}
		
		// Maximum distance to travel
		var arrow_maxNudge = Std.int(style.fontSize  * NUDGE_RATIO);
		
		arrow_tween = FlxTween.num(0, arrow_maxNudge, c.sliderTime, { type:FlxTween.LOOPING }, _arrowUpdateNudge);
		arrow_tween.active = false;
			
	}//---------------------------------------------------;
	
	// -- Autocalled from the arrow tweaner
	// Separate function so that it can also be called manually
	function _arrowUpdateNudge(v:Float)
	{
		arrows[0].x = label2.x - arrows[0].width - v;
		arrows[1].x = label2.x + label2.fieldWidth + v;
	}//---------------------------------------------------;
	// --
	override public function destroy():Void 
	{
		arrow_tween = DEST.numTween(arrow_tween);
		super.destroy();
	}//---------------------------------------------------;
	
	// Alignment Helper Flags :: 
	var flag_j:Bool;
	var flag_r:Bool;
	
	// --
	override function initElements() 
	{
		super.initElements();
	
		label2.y = label.y;
		flag_j = flag_r = false;
		
		switch(style.alignment)
		{
			case "justify":
				flag_j = true;
				
			case "right":
				flag_r = true;
				
			default:
				label2.x = label.x + EL_PADDING + label.fieldWidth + arrows[0].width;
		}

		// This will also update label pos if needed :
		updateItemData();
	}//---------------------------------------------------;
	
	// --
	// Separate function because MitemSlider uses it as well
	function updateLabel2Pos()
	{
		if (flag_j)
		{
			label2.x = x + parentWidth - arrows[0].width - label2.fieldWidth;
			
		}else
		if (flag_r)
		{
			label2.x = label.x - arrows[0].width - label2.fieldWidth - EL_PADDING;
		}else{
			// No change on actual positioning, Just update self_width
			self_width = label.fieldWidth + EL_PADDING + label2.fieldWidth + arrows[0].width;
		}
		
		_arrowUpdateNudge(arrow_tween.value);
	}//---------------------------------------------------;
	
	// --
	override function state_default() 
	{
		super.state_default();
		label2.color = style.color_accent;
		arrows[0].visible = false;
		arrows[1].visible = false;
		arrow_tween.active = false;
	}//---------------------------------------------------;
	// --
	override function state_focused() 
	{
		super.state_focused();
		label2.color = style.color_focused;
		arrow_tween.active = true;
		// Check visibility and reset nudge
		_updateArrows();
	}//---------------------------------------------------;
	// --
	override function state_disabled() 
	{
		super.state_disabled();
		label2.color = style.color_disabled;
		arrows[0].visible = false;
		arrows[1].visible = false;
		arrow_tween.active = false;
	}//---------------------------------------------------;
	
	// --
	override function handleInput(inputName:String) 
	{
		switch(inputName) {
			
			case "right":
				var c:Int = cast opt.data.current + 1;
				if (c == opt.data.pool.length) {
					if (opt.data.loop) c = 0; else return; // no more
				}
				opt.data.current = c;
				updateItemData();
				cb("change");
				
			case "left":
				var c:Int = cast opt.data.current - 1;
				if (c == -1) {
					if (opt.data.loop) c = cast opt.data.pool.length - 1; else return;
				}
				opt.data.current = c;
				updateItemData();
				cb("change");
			
			default:
				handleInputClick(inputName);
				
		}
	}//---------------------------------------------------;
	// --
	// Called once on data set, and then everytime the data changes
	function updateItemData()
	{
		if (!opt.data.loop){
			arrowStat[0] = (opt.data.current > 0);
			arrowStat[1] = (opt.data.current < opt.data.pool.length - 1);
		}else{
			arrowStat[0] = arrowStat[1] = true;
		}
		
		label2.text = opt.data.pool[opt.data.current];
		
		// Check visibility and reset nudge
		_updateArrows();
		updateLabel2Pos();
	}//---------------------------------------------------;
	
	// --
	function _updateArrows()
	{
		// Note: Arrow 2 X is calculated on update();
		// A timer of 0 forces the arrows to update on the next cycle
		
		if (isFocused)
		{
			arrows[0].visible = arrowStat[0];
			arrows[1].visible = arrowStat[1];
		}
	}//---------------------------------------------------;

	
	// Reads input and if cursor, translates the position to a new 
	// handleinputcall "left" or "right"
	function handleInputClick(inputStr:String)
	{
		var mc = getMouseCoords(inputStr);
		if (mc == null) return;
		
		var b1 = (label2.width / 3);
		var l2 = label2.x - x;
		
		// Check if clicked in the general area of the arrow
		// Starting from the middle of the label as a buffer for easier clicking
		
		if (mc[0]<l2+b1 && mc[0]>l2-arrows[0].width * 2)
			handleInput("left");
		else if (mc[0] > l2 + label2.width - b1 && mc[0] < l2 + label2.width + arrows[0].width * 2)
			handleInput("right");
	}//---------------------------------------------------;

}// -- end --